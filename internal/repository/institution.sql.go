// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: institution.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const addAccountInstitution = `-- name: AddAccountInstitution :one
WITH ins AS (
  INSERT INTO account_institutions (account_id, institution_id)
  VALUES ($1, $2)
  ON CONFLICT DO NOTHING
  RETURNING account_id, institution_id
)
SELECT account_id, institution_id FROM ins
UNION
SELECT account_id, institution_id FROM account_institutions
WHERE account_id = $1 AND institution_id = $2
`

type AddAccountInstitutionParams struct {
	AccountID     uuid.UUID `json:"account_id"`
	InstitutionID int32     `json:"institution_id"`
}

type AddAccountInstitutionRow struct {
	AccountID     uuid.UUID `json:"account_id"`
	InstitutionID int32     `json:"institution_id"`
}

func (q *Queries) AddAccountInstitution(ctx context.Context, arg AddAccountInstitutionParams) (AddAccountInstitutionRow, error) {
	row := q.db.QueryRow(ctx, addAccountInstitution, arg.AccountID, arg.InstitutionID)
	var i AddAccountInstitutionRow
	err := row.Scan(&i.AccountID, &i.InstitutionID)
	return i, err
}

const createInstitution = `-- name: CreateInstitution :one
INSERT INTO institutions (
    name, web_pages, domains, alpha_two_code, country, state_province
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING institution_id, name, web_pages, domains, alpha_two_code, country, state_province
`

type CreateInstitutionParams struct {
	Name          string   `json:"name"`
	WebPages      []string `json:"web_pages"`
	Domains       []string `json:"domains"`
	AlphaTwoCode  *string  `json:"alpha_two_code"`
	Country       *string  `json:"country"`
	StateProvince *string  `json:"state_province"`
}

func (q *Queries) CreateInstitution(ctx context.Context, arg CreateInstitutionParams) (Institution, error) {
	row := q.db.QueryRow(ctx, createInstitution,
		arg.Name,
		arg.WebPages,
		arg.Domains,
		arg.AlphaTwoCode,
		arg.Country,
		arg.StateProvince,
	)
	var i Institution
	err := row.Scan(
		&i.InstitutionID,
		&i.Name,
		&i.WebPages,
		&i.Domains,
		&i.AlphaTwoCode,
		&i.Country,
		&i.StateProvince,
	)
	return i, err
}

const deleteInstitution = `-- name: DeleteInstitution :exec
DELETE FROM institutions
WHERE institution_id = $1
`

func (q *Queries) DeleteInstitution(ctx context.Context, institutionID int32) error {
	_, err := q.db.Exec(ctx, deleteInstitution, institutionID)
	return err
}

const getInstitution = `-- name: GetInstitution :one
SELECT institution_id, name, web_pages, domains, alpha_two_code, country, state_province FROM institutions
WHERE institution_id = $1 LIMIT 1
`

func (q *Queries) GetInstitution(ctx context.Context, institutionID int32) (Institution, error) {
	row := q.db.QueryRow(ctx, getInstitution, institutionID)
	var i Institution
	err := row.Scan(
		&i.InstitutionID,
		&i.Name,
		&i.WebPages,
		&i.Domains,
		&i.AlphaTwoCode,
		&i.Country,
		&i.StateProvince,
	)
	return i, err
}

const getInstitutionsCount = `-- name: GetInstitutionsCount :one
SELECT count(*) from institutions
`

// Returns the number of all institutions in the system
func (q *Queries) GetInstitutionsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getInstitutionsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listAccountsForInstitution = `-- name: ListAccountsForInstitution :many
SELECT a.id, a.email, a.name, a.created_at, a.updated_at, a.terms_accepted, a.onboarded, a.type, a.national_id, a.username, a.avatar_url, a.bio, a.vibe_points, a.phone
FROM accounts a
JOIN account_institutions ai ON a.id = ai.account_id
WHERE ai.institution_id = $1
ORDER BY a.name
LIMIT $2
OFFSET $3
`

type ListAccountsForInstitutionParams struct {
	InstitutionID int32 `json:"institution_id"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

func (q *Queries) ListAccountsForInstitution(ctx context.Context, arg ListAccountsForInstitutionParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsForInstitution, arg.InstitutionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TermsAccepted,
			&i.Onboarded,
			&i.Type,
			&i.NationalID,
			&i.Username,
			&i.AvatarUrl,
			&i.Bio,
			&i.VibePoints,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInstitutions = `-- name: ListInstitutions :many
SELECT institution_id, name, web_pages, domains, alpha_two_code, country, state_province FROM institutions
ORDER BY institution_id LIMIT $1 OFFSET $2
`

type ListInstitutionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListInstitutions(ctx context.Context, arg ListInstitutionsParams) ([]Institution, error) {
	rows, err := q.db.Query(ctx, listInstitutions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Institution{}
	for rows.Next() {
		var i Institution
		if err := rows.Scan(
			&i.InstitutionID,
			&i.Name,
			&i.WebPages,
			&i.Domains,
			&i.AlphaTwoCode,
			&i.Country,
			&i.StateProvince,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInstitutionsForAccount = `-- name: ListInstitutionsForAccount :many
SELECT i.institution_id, i.name, i.web_pages, i.domains, i.alpha_two_code, i.country, i.state_province
FROM institutions i
JOIN account_institutions ai ON i.institution_id = ai.institution_id
WHERE ai.account_id = $1
ORDER BY i.name
LIMIT $2
OFFSET $3
`

type ListInstitutionsForAccountParams struct {
	AccountID uuid.UUID `json:"account_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListInstitutionsForAccount(ctx context.Context, arg ListInstitutionsForAccountParams) ([]Institution, error) {
	rows, err := q.db.Query(ctx, listInstitutionsForAccount, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Institution{}
	for rows.Next() {
		var i Institution
		if err := rows.Scan(
			&i.InstitutionID,
			&i.Name,
			&i.WebPages,
			&i.Domains,
			&i.AlphaTwoCode,
			&i.Country,
			&i.StateProvince,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAccountInstitution = `-- name: RemoveAccountInstitution :exec
DELETE FROM account_institutions
WHERE account_id = $1 AND institution_id = $2
`

type RemoveAccountInstitutionParams struct {
	AccountID     uuid.UUID `json:"account_id"`
	InstitutionID int32     `json:"institution_id"`
}

func (q *Queries) RemoveAccountInstitution(ctx context.Context, arg RemoveAccountInstitutionParams) error {
	_, err := q.db.Exec(ctx, removeAccountInstitution, arg.AccountID, arg.InstitutionID)
	return err
}

const searchInstitutionsByName = `-- name: SearchInstitutionsByName :many
SELECT institution_id, name, web_pages, domains, alpha_two_code, country, state_province
FROM institutions
WHERE lower(name) LIKE '%' || lower($3::varchar) || '%'
ORDER BY name
LIMIT $1 OFFSET $2
`

type SearchInstitutionsByNameParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Name   string `json:"name"`
}

func (q *Queries) SearchInstitutionsByName(ctx context.Context, arg SearchInstitutionsByNameParams) ([]Institution, error) {
	rows, err := q.db.Query(ctx, searchInstitutionsByName, arg.Limit, arg.Offset, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Institution{}
	for rows.Next() {
		var i Institution
		if err := rows.Scan(
			&i.InstitutionID,
			&i.Name,
			&i.WebPages,
			&i.Domains,
			&i.AlphaTwoCode,
			&i.Country,
			&i.StateProvince,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstitution = `-- name: UpdateInstitution :one
UPDATE institutions
SET 
    name = COALESCE(NULLIF($1::varchar, ''), name),
    web_pages = COALESCE(NULLIF($2::text[], '{}'), web_pages),
    domains = COALESCE(NULLIF($3::text[], '{}'), domains),
    alpha_two_code = COALESCE(NULLIF($4::char(2), ''), alpha_two_code),
    country = COALESCE(NULLIF($5::varchar, ''), country),
    state_province = COALESCE(NULLIF($6::varchar, ''), state_province)
WHERE institution_id = $7
RETURNING institution_id, name, web_pages, domains, alpha_two_code, country, state_province
`

type UpdateInstitutionParams struct {
	Name          string   `json:"name"`
	WebPages      []string `json:"web_pages"`
	Domains       []string `json:"domains"`
	AlphaTwoCode  string   `json:"alpha_two_code"`
	Country       string   `json:"country"`
	StateProvince string   `json:"state_province"`
	InstitutionID int32    `json:"institution_id"`
}

func (q *Queries) UpdateInstitution(ctx context.Context, arg UpdateInstitutionParams) (Institution, error) {
	row := q.db.QueryRow(ctx, updateInstitution,
		arg.Name,
		arg.WebPages,
		arg.Domains,
		arg.AlphaTwoCode,
		arg.Country,
		arg.StateProvince,
		arg.InstitutionID,
	)
	var i Institution
	err := row.Scan(
		&i.InstitutionID,
		&i.Name,
		&i.WebPages,
		&i.Domains,
		&i.AlphaTwoCode,
		&i.Country,
		&i.StateProvince,
	)
	return i, err
}
