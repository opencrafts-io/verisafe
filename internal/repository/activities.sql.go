// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activities.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createActivity = `-- name: CreateActivity :one
INSERT INTO activities (
  name, 
  description, 
  category,
  points_awarded, 
  max_daily_completions, 
  streak_eligible
) VALUES ( $1, $2, $3, $4, $5, $6 )
RETURNING id, name, description, category, points_awarded, max_daily_completions, streak_eligible, is_active, created_at, updated_at
`

type CreateActivityParams struct {
	Name                string  `json:"name"`
	Description         *string `json:"description"`
	Category            *string `json:"category"`
	PointsAwarded       int16   `json:"points_awarded"`
	MaxDailyCompletions *int16  `json:"max_daily_completions"`
	StreakEligible      *bool   `json:"streak_eligible"`
}

// Creates an activity.
// An activity is basically an action that a user can
// take to be awarded vibe points
func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, createActivity,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.PointsAwarded,
		arg.MaxDailyCompletions,
		arg.StreakEligible,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.PointsAwarded,
		&i.MaxDailyCompletions,
		&i.StreakEligible,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteActivity = `-- name: DeleteActivity :exec
DELETE FROM activities
WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteActivity, id)
	return err
}

const getActivityByID = `-- name: GetActivityByID :one
SELECT id, name, description, category, points_awarded, max_daily_completions, streak_eligible, is_active, created_at, updated_at  FROM activities WHERE id = $1
LIMIT 1
`

// Returns an activity specified by its id
func (q *Queries) GetActivityByID(ctx context.Context, id uuid.UUID) (Activity, error) {
	row := q.db.QueryRow(ctx, getActivityByID, id)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.PointsAwarded,
		&i.MaxDailyCompletions,
		&i.StreakEligible,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllActiveActivities = `-- name: GetAllActiveActivities :many
SELECT id, name, description, category, points_awarded, max_daily_completions, streak_eligible, is_active, created_at, updated_at FROM activities WHERE is_active = true LIMIT $1 OFFSET $2
`

type GetAllActiveActivitiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Returns all the active activities in the system paginated using the
// limit-offset schme
func (q *Queries) GetAllActiveActivities(ctx context.Context, arg GetAllActiveActivitiesParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, getAllActiveActivities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.PointsAwarded,
			&i.MaxDailyCompletions,
			&i.StreakEligible,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveActivitiesCount = `-- name: GetAllActiveActivitiesCount :one
SELECT COUNT(id) FROM activities WHERE is_active = true
`

// Returns all the active activities count in the system
func (q *Queries) GetAllActiveActivitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllActiveActivitiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllActivities = `-- name: GetAllActivities :many
SELECT id, name, description, category, points_awarded, max_daily_completions, streak_eligible, is_active, created_at, updated_at FROM activities LIMIT $1 OFFSET $2
`

type GetAllActivitiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Returns all the activities in the system paginated using the
// limit-offset schme
func (q *Queries) GetAllActivities(ctx context.Context, arg GetAllActivitiesParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, getAllActivities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.PointsAwarded,
			&i.MaxDailyCompletions,
			&i.StreakEligible,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActivitiesCount = `-- name: GetAllActivitiesCount :one
SELECT COUNT(id) FROM activities
`

// Returns all activities count regardless of activity status
func (q *Queries) GetAllActivitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllActivitiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllInactiveActivities = `-- name: GetAllInactiveActivities :many
SELECT id, name, description, category, points_awarded, max_daily_completions, streak_eligible, is_active, created_at, updated_at FROM activities WHERE is_active = false LIMIT $1 OFFSET $2
`

type GetAllInactiveActivitiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Returns all the inactive activities in the system paginated using the
// limit-offset schme
func (q *Queries) GetAllInactiveActivities(ctx context.Context, arg GetAllInactiveActivitiesParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, getAllInactiveActivities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.PointsAwarded,
			&i.MaxDailyCompletions,
			&i.StreakEligible,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllInactiveActivitiesCount = `-- name: GetAllInactiveActivitiesCount :one
SELECT COUNT(id) FROM activities WHERE is_active = false
`

// Returns all the inactive activities count in the system
func (q *Queries) GetAllInactiveActivitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllInactiveActivitiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllUserActivityCompletions = `-- name: GetAllUserActivityCompletions :many
SELECT id, account_id, activity_id, completed_at, completion_date, points_earned, metadata FROM activity_completions WHERE account_id = $1
LIMIT $2 OFFSET $3
`

type GetAllUserActivityCompletionsParams struct {
	AccountID uuid.UUID `json:"account_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

// Returns activity a certain user specified by their id has completed ordered
// from the most recent to the oldest
func (q *Queries) GetAllUserActivityCompletions(ctx context.Context, arg GetAllUserActivityCompletionsParams) ([]ActivityCompletion, error) {
	rows, err := q.db.Query(ctx, getAllUserActivityCompletions, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityCompletion{}
	for rows.Next() {
		var i ActivityCompletion
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.ActivityID,
			&i.CompletedAt,
			&i.CompletionDate,
			&i.PointsEarned,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserActivityCompletionsCount = `-- name: GetAllUserActivityCompletionsCount :one
SELECT count(id) FROM activity_completions WHERE account_id = $1
`

// Returns the number of record that have been done on the user's completed
// activities
func (q *Queries) GetAllUserActivityCompletionsCount(ctx context.Context, accountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getAllUserActivityCompletionsCount, accountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateActivity = `-- name: UpdateActivity :one
UPDATE activities
  SET 
    name = COALESCE(NULLIF($2::varchar,''), name),
    description = COALESCE(NULLIF($3::varchar,''), description),
    category = COALESCE(NULLIF($4::varchar,''), category),
    points_awarded = COALESCE(NULLIF($5::smallint,0), points_awarded),
    max_daily_completions = COALESCE(NULLIF($6::smallint,0), max_daily_completions),
    streak_eligible = COALESCE(NULLIF($7::boolean,false), streak_eligible),
    is_active = COALESCE(NULLIF($8::boolean,false), is_active),
    updated_at = NOW()
  WHERE id = $1
RETURNING id, name, description, category, points_awarded, max_daily_completions, streak_eligible, is_active, created_at, updated_at
`

type UpdateActivityParams struct {
	ID                  uuid.UUID `json:"id"`
	Name                string    `json:"name"`
	Description         string    `json:"description"`
	Category            string    `json:"category"`
	PointsAwarded       int16     `json:"points_awarded"`
	MaxDailyCompletions int16     `json:"max_daily_completions"`
	StreakEligible      bool      `json:"streak_eligible"`
	IsActive            bool      `json:"is_active"`
}

// Updates an activity specified by its ID
func (q *Queries) UpdateActivity(ctx context.Context, arg UpdateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, updateActivity,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.PointsAwarded,
		arg.MaxDailyCompletions,
		arg.StreakEligible,
		arg.IsActive,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.PointsAwarded,
		&i.MaxDailyCompletions,
		&i.StreakEligible,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
