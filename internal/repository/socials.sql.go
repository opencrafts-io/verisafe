// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: socials.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSocial = `-- name: CreateSocial :one
INSERT INTO socials (
    account_id,
    provider,
    email,
    name,
    first_name,
    last_name,
    nick_name,
    description,
    user_id,
    avatar_url,
    location,
    access_token,
    access_token_secret,
    refresh_token,
    expires_at
)
VALUES (
    $1, -- account_id UUID
    $2, -- provider VARCHAR
    $3, -- email VARCHAR
    $4, -- name VARCHAR
    $5, -- first_name VARCHAR
    $6, -- last_name VARCHAR
    $7, -- nick_name VARCHAR
    $8, -- description TEXT
    $9, -- user_id VARCHAR
    $10, -- avatar_url TEXT
    $11, -- location VARCHAR
    $12, -- access_token TEXT
    $13, -- access_token_secret TEXT
    $14, -- refresh_token TEXT
    $15  -- expires_at TIMESTAMP
)
RETURNING user_id, id_token, account_id, provider, email, name, first_name, last_name, nick_name, description, avatar_url, location, access_token, access_token_secret, refresh_token, expires_at, created_at, updated_at
`

type CreateSocialParams struct {
	AccountID         uuid.UUID        `json:"account_id"`
	Provider          string           `json:"provider"`
	Email             *string          `json:"email"`
	Name              *string          `json:"name"`
	FirstName         *string          `json:"first_name"`
	LastName          *string          `json:"last_name"`
	NickName          *string          `json:"nick_name"`
	Description       *string          `json:"description"`
	UserID            string           `json:"user_id"`
	AvatarUrl         *string          `json:"avatar_url"`
	Location          *string          `json:"location"`
	AccessToken       *string          `json:"access_token"`
	AccessTokenSecret *string          `json:"access_token_secret"`
	RefreshToken      *string          `json:"refresh_token"`
	ExpiresAt         pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateSocial(ctx context.Context, arg CreateSocialParams) (Social, error) {
	row := q.db.QueryRow(ctx, createSocial,
		arg.AccountID,
		arg.Provider,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.NickName,
		arg.Description,
		arg.UserID,
		arg.AvatarUrl,
		arg.Location,
		arg.AccessToken,
		arg.AccessTokenSecret,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	var i Social
	err := row.Scan(
		&i.UserID,
		&i.IDToken,
		&i.AccountID,
		&i.Provider,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.NickName,
		&i.Description,
		&i.AvatarUrl,
		&i.Location,
		&i.AccessToken,
		&i.AccessTokenSecret,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByProvider = `-- name: GetAccountByProvider :many
SELECT user_id, id_token, account_id, provider, email, name, first_name, last_name, nick_name, description, avatar_url, location, access_token, access_token_secret, refresh_token, expires_at, created_at, updated_at FROM socials
WHERE lower(provider) = lower($1)
LIMIT $2
OFFSET $3
`

type GetAccountByProviderParams struct {
	Lower  string `json:"lower"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

// Returns a list of all social accounts by provider
// note that the results are paginated using the limit offset scheme
func (q *Queries) GetAccountByProvider(ctx context.Context, arg GetAccountByProviderParams) ([]Social, error) {
	rows, err := q.db.Query(ctx, getAccountByProvider, arg.Lower, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Social{}
	for rows.Next() {
		var i Social
		if err := rows.Scan(
			&i.UserID,
			&i.IDToken,
			&i.AccountID,
			&i.Provider,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.NickName,
			&i.Description,
			&i.AvatarUrl,
			&i.Location,
			&i.AccessToken,
			&i.AccessTokenSecret,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAccountSocials = `-- name: GetAllAccountSocials :many
SELECT user_id, id_token, account_id, provider, email, name, first_name, last_name, nick_name, description, avatar_url, location, access_token, access_token_secret, refresh_token, expires_at, created_at, updated_at FROM socials
WHERE account_id = $1
`

// Returns a list of oauth providers that they've granted
// note that the results are not paginated since we dont support a
// whole lot of social oauth providers
func (q *Queries) GetAllAccountSocials(ctx context.Context, accountID uuid.UUID) ([]Social, error) {
	rows, err := q.db.Query(ctx, getAllAccountSocials, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Social{}
	for rows.Next() {
		var i Social
		if err := rows.Scan(
			&i.UserID,
			&i.IDToken,
			&i.AccountID,
			&i.Provider,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.NickName,
			&i.Description,
			&i.AvatarUrl,
			&i.Location,
			&i.AccessToken,
			&i.AccessTokenSecret,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialByExternalUserID = `-- name: GetSocialByExternalUserID :one
SELECT user_id, id_token, account_id, provider, email, name, first_name, last_name, nick_name, description, avatar_url, location, access_token, access_token_secret, refresh_token, expires_at, created_at, updated_at FROM socials
WHERE user_id = $1
`

func (q *Queries) GetSocialByExternalUserID(ctx context.Context, userID string) (Social, error) {
	row := q.db.QueryRow(ctx, getSocialByExternalUserID, userID)
	var i Social
	err := row.Scan(
		&i.UserID,
		&i.IDToken,
		&i.AccountID,
		&i.Provider,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.NickName,
		&i.Description,
		&i.AvatarUrl,
		&i.Location,
		&i.AccessToken,
		&i.AccessTokenSecret,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSocial = `-- name: UpdateSocial :one
UPDATE socials
SET
    email = COALESCE(NULLIF($4::varchar,''), email),
    name = COALESCE(NULLIF($5::varchar,''), name),
    first_name = COALESCE(NULLIF($6::varchar,''), first_name),
    last_name = COALESCE(NULLIF($7::varchar,''), last_name),
    nick_name = COALESCE(NULLIF($8::varchar,''), nick_name),
    description = COALESCE(NULLIF($9::text,''), description),
    avatar_url = COALESCE(NULLIF($10::text,''), avatar_url),
    location = COALESCE(NULLIF($11::varchar,''), location),
    refresh_token = COALESCE(NULLIF($12::text,''), refresh_token),
    access_token = COALESCE(NULLIF($13::text,''), access_token),
    access_token_secret = COALESCE(NULLIF($14::text,''), access_token_secret),
    expires_at = COALESCE($3, expires_at),
    updated_at = NOW()
WHERE user_id = $1 AND provider = $2
RETURNING user_id, id_token, account_id, provider, email, name, first_name, last_name, nick_name, description, avatar_url, location, access_token, access_token_secret, refresh_token, expires_at, created_at, updated_at
`

type UpdateSocialParams struct {
	UserID            string           `json:"user_id"`
	Provider          string           `json:"provider"`
	ExpiresAt         pgtype.Timestamp `json:"expires_at"`
	Email             string           `json:"email"`
	Name              string           `json:"name"`
	FirstName         string           `json:"first_name"`
	LastName          string           `json:"last_name"`
	NickName          string           `json:"nick_name"`
	Description       string           `json:"description"`
	AvatarUrl         string           `json:"avatar_url"`
	Location          string           `json:"location"`
	RefreshToken      string           `json:"refresh_token"`
	AccessToken       string           `json:"access_token"`
	AccessTokenSecret string           `json:"access_token_secret"`
}

func (q *Queries) UpdateSocial(ctx context.Context, arg UpdateSocialParams) (Social, error) {
	row := q.db.QueryRow(ctx, updateSocial,
		arg.UserID,
		arg.Provider,
		arg.ExpiresAt,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.NickName,
		arg.Description,
		arg.AvatarUrl,
		arg.Location,
		arg.RefreshToken,
		arg.AccessToken,
		arg.AccessTokenSecret,
	)
	var i Social
	err := row.Scan(
		&i.UserID,
		&i.IDToken,
		&i.AccountID,
		&i.Provider,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.NickName,
		&i.Description,
		&i.AvatarUrl,
		&i.Location,
		&i.AccessToken,
		&i.AccessTokenSecret,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
